/**
 * Medoto per la creazione dell'oggeto da salvare nella tabella Articles
 * La tabella Articles contiene tutti gli articoli che ci vengono notificati da VENUX
 * Questo metodo utlizza tutti i campi comuni a tutti i core di SOLR
 * In valueToUse è presente il valore della request contente l'oggetto da convertire in entity,
 * mentre in entityGenerator è presente 
 */
var jsStringEscape = require('js-string-escape');
var crypto = require('crypto');
exports.setSolrArticleEntity = function(valueToUse, entityGenerator) {
    
    var valueToHash = '';
    
    var autore = ''; //
     if (typeof valueToUse.autore !== 'undefined' && valueToUse.autore) {
        autore = encodeURIComponent(valueToUse.autore)
        valueToHash += autore;
    }
    var collection = ''; //
    if (typeof valueToUse.collection !== 'undefined' && valueToUse.collection) {
        collection = encodeURIComponent(valueToUse.collection)
        valueToHash += collection
    }
     var commentabilita ='' ;
     if (typeof valueToUse.commentabilita !== 'undefined' && valueToUse.commentabilita) {
        commentabilita = encodeURIComponent(valueToUse.commentabilita)
        valueToHash += commentabilita
    }
    var companies = ''; //
     if (typeof valueToUse.companies !== 'undefined' && valueToUse.companies) {
        companies = encodeURIComponent(valueToUse.companies)
        valueToHash += companies
    }
    var data = ''; //
     if (typeof valueToUse.data !== 'undefined' && valueToUse.data) {
        data = encodeURIComponent(valueToUse.data)
        valueToHash += data
    }
    var datamod = ''; //
     if (typeof valueToUse.datamod !== 'undefined' && valueToUse.datamod) {
        datamod = encodeURIComponent(valueToUse.datamod)
        valueToHash += datamod
    }
    var entities = ''; //
     if (typeof valueToUse.entities !== 'undefined' && valueToUse.entities) {
        entities = encodeURIComponent(valueToUse.entities)
        valueToHash += entities
    }
    var entities_group = ''; // --> ARRAY DI STRINGHE
    var entitiesGroupString = "";
     if (typeof valueToUse.entities_group !== 'undefined' && valueToUse.entities_group) {
        entities_group = (valueToUse.entities_group)       
        entities_group.forEach(function(item, index) {
            entitiesGroupString += encodeURIComponent(entities_group[index]) + "|";
        })
        valueToHash += entitiesGroupString
    }
     var formato ='' ;
     if (typeof valueToUse.formato !== 'undefined' && valueToUse.formato) {
        formato = encodeURIComponent(valueToUse.formato)
        valueToHash += formato
    }
    var id = ''; // 
     if (typeof valueToUse.id !== 'undefined' && valueToUse.id) {
        id = encodeURIComponent(valueToUse.id)
        valueToHash +=id
    }
     var id_film ='' ;
     if (typeof valueToUse.idFilm !== 'undefined' && valueToUse.id_film) {
        id_film = encodeURIComponent(valueToUse.id_film)
        valueToHash += id_film
    }  
    var idapplication = ''; //
     if (typeof valueToUse.idapplication !== 'undefined' && valueToUse.idapplication) {
        idapplication = encodeURIComponent(valueToUse.idapplication)
        valueToHash += idapplication
    }
     var indirizzo_url ='' ;
     if (typeof valueToUse.indirizzo_url !== 'undefined' && valueToUse.indirizzo_url) {
        indirizzo_url = encodeURIComponent(valueToUse.indirizzo_url)
        valueToHash += indirizzo_url
    }
    var indirizzo_url_web ='' ;
     if (typeof valueToUse.indirizzo_url_web !== 'undefined' && valueToUse.indirizzo_url_web) {
        indirizzo_url_web = encodeURIComponent(valueToUse.indirizzo_url_web)
        valueToHash += indirizzo_url_web
    }   
    var keywords = ''; // STRINGA
     if (typeof valueToUse.keywords !== 'undefined' && valueToUse.keywords) {
        keywords = encodeURIComponent(valueToUse.keywords)
        valueToHash += keywords
    }
    var month_facet_field = ''; //
     if (typeof valueToUse.month_facet_field !== 'undefined' && valueToUse.month_facet_field) {
        month_facet_field = encodeURIComponent(valueToUse.month_facet_field)
        valueToHash += month_facet_field
    }
    var motore_ricerca_interno = ''; //
     if (typeof valueToUse.motore_ricerca_interno !== 'undefined' && valueToUse.motore_ricerca_interno) {
        motore_ricerca_interno = encodeURIComponent(valueToUse.motore_ricerca_interno)
        valueToHash += motore_ricerca_interno
    }
    var occhiello = ''; //
     if (typeof valueToUse.occhiello !== 'undefined' && valueToUse.occhiello) {
        occhiello = encodeURIComponent(valueToUse.occhiello)
        valueToHash += occhiello
    }
    var people = ''; // --> ARRAY DI STRINGHE
    var peopleString = "";
     if (typeof valueToUse.people !== 'undefined' && valueToUse.people) {
        people = (valueToUse.people)
        people.forEach(function(item, index) {
            peopleString += encodeURIComponent(people[index]) + "|";
            });
        valueToHash += peopleString
    } 
    var photo_name ='' ;
     if (typeof valueToUse.photo_name !== 'undefined' && valueToUse.photo_name) {
        photo_name = encodeURIComponent(valueToUse.photo_name)
        valueToHash += photo_name
    }
    var photo_dida ='' ;
     if (typeof valueToUse.photo_dida !== 'undefined' && valueToUse.photo_dida) {
        photo_dida = encodeURIComponent(valueToUse.photo_dida)
        valueToHash += photo_dida
    }
    var places = ''; // --> ARRAY DI STRINGHE
    var placesString = "";
     if (typeof valueToUse.places !== 'undefined' && valueToUse.places) {
        places = (valueToUse.places)
        places.forEach(function(item, index) {
            placesString += encodeURIComponent(places[index]) + "|";
        });
        valueToHash = placesString
    }
    var price_type ='' ;
      if (typeof valueToUse.price_type !== 'undefined' && valueToUse.price_type) {
         price_type = encodeURIComponent(valueToUse.price_type)
         valueToHash += price_type
    }    
    var product_type ='' ;
      if (typeof valueToUse.product_type !== 'undefined' && valueToUse.product_type) {
        product_type = jsStringEscape(valueToUse.product_type)
        valueToHash += product_type
    } 
    var relative_path = '';
     if (typeof valueToUse.relative_path !== 'undefined' && valueToUse.relative_path) {
        relative_path = encodeURIComponent(valueToUse.relative_path)
        valueToHash += relative_path
    }
    var release ='' ;
     if (typeof valueToUse.release !== 'undefined' && valueToUse.release) {
        release = encodeURIComponent(valueToUse.release)
        valueToHash += release
    } 
    var send_appmobile ='' ;
      if (typeof valueToUse.send_appmobile !== 'undefined' && valueToUse.send_appmobile) {
        send_appmobile = encodeURIComponent(valueToUse.send_appmobile)
        valueToHash += send_appmobile
    }
    var sezione ='' ;
     if (typeof valueToUse.sezione !== 'undefined' && valueToUse.sezione) {
        sezione = encodeURIComponent(valueToUse.sezione)
        valueToHash += sezione
    }
    var sottosezione ='' ;
     if (typeof valueToUse.sottosezione !== 'undefined' && valueToUse.sottosezione) {
        sottosezione = encodeURIComponent(valueToUse.sottosezione)
        valueToHash += sottosezione
    }
    var sottotitolo ='' ;
     if (typeof valueToUse.sottotitolo !== 'undefined' && valueToUse.sottotitolo) {
        sottotitolo = encodeURIComponent(valueToUse.sottotitolo)
        valueToHash += sottotitolo
    }
    var tags ='' ; // --> ARRAY DI STRINGHE
    var tagsString = "";
     if (typeof valueToUse.tags !== 'undefined' && valueToUse.tags) {
        tags = (valueToUse.tags)
         tags.forEach(function(item, index) {
            tagsString += encodeURIComponent(tags[index]) + "|";
        });
        valueToHash += tagsString
    }    
    var testata ='' ;
     if (typeof valueToUse.testata !== 'undefined' && valueToUse.testata) {
        testata = encodeURIComponent(valueToUse.testata)
        valueToHash += testata
    }
    var testo ='' ;
     if (typeof valueToUse.testo !== 'undefined' && valueToUse.testo) {
        testo = encodeURIComponent(valueToUse.testo);
        valueToHash += testo
    }
    var testo_ricerca ='' ;
      if (typeof valueToUse.testo_ricerca !== 'undefined' && valueToUse.testo_ricerca) {
        testo_ricerca = encodeURIComponent(valueToUse.testo_ricerca)
        valueToHash += testo_ricerca
    }
    var thumbnail ='';
     if (typeof valueToUse.thumbnail !== 'undefined' && valueToUse.thumbnail) {
        thumbnail = encodeURIComponent(valueToUse.thumbnail)
        valueToHash += thumbnail
    }     
    var tipodocumento ='' ;
     if (typeof valueToUse.tipodocumento !== 'undefined' && valueToUse.tipodocumento) {
        tipodocumento = encodeURIComponent(valueToUse.tipodocumento)
        valueToHash += tipodocumento
    }    
    var titolo ='' ;
     if (typeof valueToUse.titolo !== 'undefined' && valueToUse.titolo) {
        titolo = encodeURIComponent(valueToUse.titolo)
        valueToHash += titolo
    }
    var topics_group ='' ;
     if (typeof valueToUse.topics_group !== 'undefined' && valueToUse.topics_group) {
        topics_group = encodeURIComponent(valueToUse.topics_group)
        valueToHash += topics_group
    } 
    var url_mobile ='' ;
     if (typeof valueToUse.url_mobile !== 'undefined' && valueToUse.url_mobile) {
        url_mobile = encodeURIComponent(valueToUse.url_mobile)
        valueToHash += url_mobile
    }
    var url_appmobile ='' ;
      if (typeof valueToUse.url_appmobile !== 'undefined' && valueToUse.url_appmobile) {
        url_appmobile = encodeURIComponent(valueToUse.url_appmobile)
        valueToHash += url_appmobile
    }
    var uuid ='' ;
      if (typeof valueToUse.uuid !== 'undefined' && valueToUse.uuid) {
        uuid = encodeURIComponent(valueToUse.uuid)
        valueToHash += uuid
    }    
    var year_facet_field ='' ;
     if (typeof valueToUse.year_facet_field !== 'undefined' && valueToUse.year_facet_field) {
        year_facet_field = encodeURIComponent(valueToUse.year_facet_field)
        valueToHash += year_facet_field
    }
    
    //creo l'hash di tutti i valori letti in modo da avere una striga univoca e utilizzarla come chiave
    var hash = crypto.createHash('sha256');
    var hashValueForKey = hash.update('valueToHash').digest('hex')   
     
    console.log("hashValueForKey: " + hashValueForKey)
    var entityToWrite = {
        PartitionKey: entityGenerator.String('articles'),
        RowKey: entityGenerator.String(hashValueForKey),
        Autore: entityGenerator.String(autore),
        Collection: entityGenerator.String(collection),
        Commentabilita: entityGenerator.String(commentabilita),        
        Companies: entityGenerator.String(companies),
        Data: entityGenerator.String(data),
        DataMod: entityGenerator.String(datamod),
        Entitites: entityGenerator.String(entities),
        EntitiesGroup: entityGenerator.String(entitiesGroupString),
        Formato: entityGenerator.String(formato),        
        Id: entityGenerator.String(id),
        IdApplication: entityGenerator.String(idapplication),
        IdFilm: entityGenerator.String(id_film),
        IndirizzoUrl: entityGenerator.String(indirizzo_url),
        IndirizzoUrlWeb: entityGenerator.String(indirizzo_url_web),
        Keywords: entityGenerator.String(jsStringEscape(keywords)),
        MonthFacetField: entityGenerator.String(month_facet_field),
        MotoreRicercaInterno: entityGenerator.String(motore_ricerca_interno),
        Occhiello: entityGenerator.String(jsStringEscape(occhiello)),
        People: entityGenerator.String(peopleString),
        PhotoName: entityGenerator.String(photo_name),
        PhotoDida: entityGenerator.String(photo_dida),
        Places: entityGenerator.String(placesString),
        PriceType: entityGenerator.String(price_type),
        ProductType: entityGenerator.String(product_type),
        RelativePath: entityGenerator.String(relative_path),
        Release: entityGenerator.String(release),
        SendAppMobile: entityGenerator.Boolean(send_appmobile),
        Sezione: entityGenerator.String(sezione),
        Sottosezione: entityGenerator.String(sottosezione),
        Sottotitolo: entityGenerator.String(jsStringEscape(sottotitolo)),
        Tags: entityGenerator.String(tagsString),       
        Testata: entityGenerator.String(testata),
        Testo: entityGenerator.String(jsStringEscape(testo)),
        TestoRicerca: entityGenerator.String(testo_ricerca),
        Thumbnail: entityGenerator.String(thumbnail),
        TipoDocumento: entityGenerator.String(tipodocumento),
        Titolo: entityGenerator.String(jsStringEscape(titolo)),
        TopicsGroup: entityGenerator.String(topics_group),
        UlrMobile: entityGenerator.String(url_mobile),
        UrlAppMobile: entityGenerator.String(url_appmobile),
        UUID: entityGenerator.String(uuid),
        YearFacetField: entityGenerator.String(year_facet_field)        
    };

    return entityToWrite;
}


/**
 * Medoto per la creazione dell'oggeto da salvare nella tabella Articles
 * La tabella Articles contiene tutti gli articoli che ci vengono notificati da VENUX
 * Questo metodo utlizza tutti i campi comuni a tutti i core di SOLR
 * In valueToUse è presente il valore della request contente l'oggetto da convertire in entity,
 * mentre in entityGenerator è presente 
 */
exports.setUserNavigationEntity = function(valueToUse, entityGenerator) {
    //Dichiaro le variabili    
    var preferences = ''; // Array di stringhe, deve dinvetare uno stringone separato da |
    var runaid = '';
    var article_uuid = '';
    var reading_time = '';
    var favourite = '';
    var mio_corriere = '';
    var related = '';
    var search = '';
    var city = '';
    var gps_position = '';  // Oggetto, deve diventare uno stringone composto latitute:[latitute]|longitude:[longitude]
    var sharing = '';
    var timestamp = '';

    var valueToHash = '';

    //contorllo il contenuto dei valori ricevuti e se presenti popolo le variabili
    if (typeof valueToUse.preferences !== 'undefined' && valueToUse.preferences) {
        preferences = valueToUse.preferences;
        var preferencesString = "";
        preferences.forEach(function(item, index) {
            preferencesString += preferences[index] + "|";
        })
        valueToHash += preferencesString;
    }
    if (typeof valueToUse.runaid !== 'undefined' && valueToUse.runaid) {
        runaid = encodeURIComponent(valueToUse.runaid);
        valueToHash += runaid 
    }
    if (typeof valueToUse.article_uuid !== 'undefined' && valueToUse.article_uuid) {
        article_uuid = encodeURIComponent(valueToUse.article_uuid);
        valueToHash += article_uuid
    }
    if (typeof valueToUse.reading_time !== 'undefined' && valueToUse.reading_time) {
        reading_time = encodeURIComponent(valueToUse.reading_time);
        valueToHash += reading_time
    }
    if (typeof valueToUse.favourite !== 'undefined' && valueToUse.favourite) {
        favourite = encodeURIComponent(valueToUse.favourite);
        valueToHash += favourite
    }
    if (typeof valueToUse.related !== 'undefined' && valueToUse.related) {
        related = encodeURIComponent(valueToUse.related);
        valueToHash += related
    }
    if (typeof valueToUse.search !== 'undefined' && valueToUse.search) {
        search = encodeURIComponent(valueToUse.search);
        valueToHash += search
    }
    if (typeof valueToUse.city !== 'undefined' && valueToUse.city) {
        city = encodeURIComponent(valueToUse.city);
        valueToHash += city
    }
    if (typeof valueToUse.gps_position !== 'undefined' && valueToUse.gps_position) {
        gps_position = JSON.stringify(valueToUse.gps_position);
        valueToHash += gps_position
    }
    if (typeof valueToUse.sharing !== 'undefined' && valueToUse.sharing) {
        sharing = encodeURIComponent(valueToUse.sharing);
        valueToHash += sharing
    }
    if (typeof valueToUse.timestamp !== 'undefined' && valueToUse.timestamp) {
        timestamp = encodeURIComponent(valueToUse.timestamp);
        valueToHash += timestamp
    }

    
    var hash = crypto.createHash('sha256')
    var hashValueForKey = hash.update(valueToHash).digest('hex');


    //una volta formattati li scrivo sulle tabelle di azure MachineLearning      
    var date = new Date();      
    var entityToWrite = {
        PartitionKey: entityGenerator.String('usertracking'),
        RowKey: entityGenerator.String(hashValueForKey), //aggiungere il timestamp o vedere utilizzo sequence
        Category: entityGenerator.String(preferencesString),
        RunaId: entityGenerator.String(runaid),
        ArticleUUID: entityGenerator.String(article_uuid),
        ReadingTime: entityGenerator.String(reading_time),
        Favourite: entityGenerator.Boolean(favourite),
        MioCorriere: entityGenerator.Boolean(mio_corriere),
        Related: entityGenerator.Boolean(related),
        Search: entityGenerator.String(search),
        City: entityGenerator.String(city),
        GpsPos: entityGenerator.String(gps_position),
        Sharing: entityGenerator.String(sharing),
        Timestamp: entityGenerator.String(timestamp)
    };

    return entityToWrite;
}


exports.setUserDetailEntity = function(valueToUse, entityGenerator) {

    var valueToHash = '';

    var iduser = encodeURIComponent(valueToUse.iduser); // --> leggo term dal body della request, nel nostro caso un JSON
    var birthdate = encodeURIComponent(valueToUse.birthdate); // --> leggo term dal body della request, nel nostro caso un JSON
    var usertype = encodeURIComponent(valueToUse.usertype); // --> leggo term dal body della request, nel nostro caso un JSON
    var city = encodeURIComponent(valueToUse.city); // --> leggo term dal body della request, nel nostro caso un JSON
    var provinceid = encodeURIComponent(valueToUse.provinceid); // --> leggo term dal body della request, nel nostro caso un JSON
    var countryid = encodeURIComponent(valueToUse.countryid); // --> leggo term dal body della request, nel nostro caso un JSON
    var gender = encodeURIComponent(valueToUse.gender); // --> leggo term dal body della request, nel nostro caso un JSON
    var jobid = encodeURIComponent(valueToUse.jobid); // --> leggo term dal body della request, nel nostro caso un JSON 
    var schoolqualid = encodeURIComponent(valueToUse.schoolqualid); // --> leggo term dal body della request, nel nostro caso un JSON       
    var maritalstatusid = encodeURIComponent(valueToUse.maritalstatusid); // --> leggo term dal body della request, nel nostro caso un JSON
    var childrennumbid = encodeURIComponent(valueToUse.childrennumbid);
    
    valueToHash += iduser + birthdate + usertype + city + provinceid + countryid + gender + jobid + schoolqualid + maritalstatusid + childrennumbid

    var hash = crypto.createHash('sha256')
    var hashValueForKey = hash.update(valueToHash).digest('hex');

    //una volta formattati li scrivo sulle tabelle di azure MachineLearning            
    var entityToWrite = {
        PartitionKey: entityGenerator.String('userprofiles'),
        RowKey: entityGenerator.String(hashValueForKey),
        IdUser: entityGenerator.String(iduser),
        Birthdate: entityGenerator.String(birthdate),
        UserType: entityGenerator.String(usertype),
        City: entityGenerator.String(city),
        ProvinceId: entityGenerator.String(provinceid),
        CountryId: entityGenerator.String(countryid),
        Gender: entityGenerator.String(gender),
        JobId: entityGenerator.String(jobid),
        SchoolQualId: entityGenerator.String(schoolqualid),
        MaritalStatusId: entityGenerator.String(maritalstatusid),
        ChildrenNumbId: entityGenerator.String(childrennumbid)
    };

    return entityToWrite;
}
